// Access jsPDF from the window object (CDN load)
const { jsPDF } = window.jspdf;

// DOM Elements
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const statusContainer = document.getElementById('status-container');
const progressBar = document.getElementById('progress-bar-fill');
const statusText = document.getElementById('status-text');
const downloadBtn = document.getElementById('download-btn');
const warningBox = document.getElementById('resolution-warning');
const warningDetails = document.getElementById('warning-details');
const consoleDisplay = document.getElementById('console-log-display');

// Debug Logger
function logDebug(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const msg = `[${timestamp}] ${message}`;
    
    // Log to Browser Console
    if(type === 'error') console.error(msg);
    else if(type === 'success') console.log(`%c${msg}`, 'color: green');
    else console.log(msg);

    // Log to UI
    const logItem = document.createElement('div');
    logItem.className = `log-item log-${type}`;
    logItem.textContent = msg;
    consoleDisplay.appendChild(logItem);
    consoleDisplay.scrollTop = consoleDisplay.scrollHeight;
}

// Event Listeners for Drag & Drop
dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('drag-over');
});

dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('drag-over');
});

dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('drag-over');
    const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
    if(files.length > 0) processFiles(files);
    else logDebug('No valid image files dropped', 'error');
});

// Event Listener for Click
fileInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files).filter(file => file.type.startsWith('image/'));
    if(files.length > 0) processFiles(files);
});

// Main Processing Function
async function processFiles(files) {
    // Reset UI
    downloadBtn.classList.add('hidden');
    warningBox.classList.add('hidden');
    statusContainer.classList.remove('hidden');
    consoleDisplay.innerHTML = '';
    
    // Sort files by name to keep sequence correct
    files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

    logDebug(`Started processing ${files.length} images...`);

    // Initialize PDF. 
    // We start with a dummy page, but we will set specific dimensions for every page added.
    const pdf = new jsPDF({
        orientation: 'p',
        unit: 'px',
        format: [100, 100], // Temporary, will change per page
        compress: false // IMPORTANT: Disable default compression to keep quality
    });

    // Remove the default first page generated by jsPDF
    pdf.deletePage(1);

    let resolutionLossOccurred = false;
    let lossDetails = [];

    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Update Progress
        const percent = Math.round(((i + 1) / files.length) * 100);
        progressBar.style.width = `${percent}%`;
        statusText.innerText = `Converting ${file.name} (${i + 1}/${files.length})`;

        try {
            const imgData = await readFileAsDataURL(file);
            const dims = await getImageDimensions(imgData);

            logDebug(`Image: ${file.name} | Dimensions: ${dims.width}x${dims.height}px`);

            // Add a new page with the EXACT dimensions of the image
            // format: [width, height] ensures 1:1 pixel mapping
            pdf.addPage([dims.width, dims.height], dims.width > dims.height ? 'l' : 'p');

            // Add image to the full page. 
            // 'null' for alias, 'NONE' for compression ensures no re-encoding if supported,
            // though 'FAST' is often safer for PNG transparency in jsPDF while keeping high quality.
            // Using 'SLOW' generates best compression but we want NO loss, so we trust dimensions.
            
            // width and height set to dims.width/height ensures no downscaling.
            pdf.addImage(imgData, getFileType(file), 0, 0, dims.width, dims.height, null, 'NONE');

            // Verification Check (Simulated)
            // Since we explicitly set the page size to the image size, 
            // logic dictates loss is 0% unless image is corrupt.
            const verifyScale = 1; // 1:1
            if (verifyScale !== 1) {
                resolutionLossOccurred = true;
                lossDetails.push(`${file.name}: scaled down`);
            }

        } catch (err) {
            logDebug(`Error processing ${file.name}: ${err.message}`, 'error');
        }
    }

    // Finalize
    statusText.innerText = 'Conversion Complete!';
    
    // Check for "Loss" (Logic based on 1:1 mapping failing, which shouldn't happen here)
    if (resolutionLossOccurred) {
        warningBox.classList.remove('hidden');
        warningDetails.innerHTML = lossDetails.join('<br>');
    } else {
        logDebug('Success: 0% Resolution Loss. PDF pages matched image dimensions.', 'success');
    }

    // Setup Download
    downloadBtn.classList.remove('hidden');
    downloadBtn.onclick = () => {
        logDebug('Generating PDF Blob...');
        pdf.save('combined-images.pdf');
    };
}

// Helper: Read File
function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// Helper: Get Image Dimensions
function getImageDimensions(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ width: img.width, height: img.height });
        img.onerror = reject;
        img.src = url;
    });
}

// Helper: Map mime type to jsPDF format
function getFileType(file) {
    if (file.type === 'image/png') return 'PNG';
    if (file.type === 'image/jpeg' || file.type === 'image/jpg') return 'JPEG';
    return 'PNG'; // Fallback
}